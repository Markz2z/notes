Linux MM 简介
==============

地址映射
-----------------
通过页表实现(页表放在内存中，地址转换由CPU MMU模块来完成，为提高性能，会有专门cache `TLB: Translation lookaside buffer`)。所以局部性很重要(不仅数据cache需要cache，TLB也需要局部性，进程切换TLB会失效)。
注意：无论，用户态还是内核态，都是虚拟地址，即都是经过了mmu转换(但页表里的内容是物理地址--这是显然的)。内核的页表是写死的(理论上来说应该也可以修改，比如扩展内核内存使用大小，只要在访问前自己添加映射--页表位置固定，缺页的话肯定oops)，用户的页表可以由内核修改。

Q：为何需要用户空间与内核空间内存的拷贝？  
A：因为页表不同，映射不同，所以不能直接访问，需要建立临时映射拷贝然后解除映射(类似HIGH内存)。

虚拟地址管理
-----------------
每个进程有一个task结构，其中有一项mm结构(线程间共享此结构)，mm->pgd指向存放页表的内存。用户态执行时，一般CPU有一个寄存器(X86使用CR3)保存页表地址，所以内核只需要对寄存器赋值就可以切换不同的进程空间，然后返回用户态实现调度(当然还需回复寄存器等)。mm具体的管理是采用分区域(area)的方式(如代码区，数据区，堆，栈，各种mmap的内存等)，vma通过链表(遍历)和红黑树(查找)进行管理(在进程的vma较少时，内核采用链表来管理vma；vma较多时，改用红黑树来管理)。用户程序申请内存(brk或者mmap)仅仅修改vma对应的区域(比如合并相邻区域)管理信息(比如线性地址，权限，映射的文件等等元信息)，并不修改页表，仅当用户程序真正读取对应的内存时发生缺页中断，内核检查发生缺页的地址，并查找对应的vma区域，是否申请物理页面(可能会涉及evict其他page frame到交换区？)并更新进程页表或者出发segmentation fault (内核应该有专门模块管理物理内存的分配，跟进程页表的更新是正交关系)。

用户空间的堆在内核中是一个一端固定，一端可以增减的vma。malloc时可以通过brk调用进行增长，free时有可能会缩减(但由于分配释放的随机性，显然很难)。所以对于大块内存，malloc采用mmap直接分配vma，munmap时可以释放，由于vma操作开销大(链表，红黑树，页表修改，缺页中断，系统调用等)且都是整页的，所以仅适合大块内存。

用户进程的栈也是一个vma，一端固定，一端可伸展(但不可缩小)。但是内核限制了最大可伸展的大小(一般为8M)，超过会发生fault。线程由于共享mm，所以不能使用此vma，而是由libc线程库通过mmap来创建一个vma作为线程栈(一般为2M)。其增长是通过缺页中断来实现的。

物理内存管理
------------------
首先进入保护模式时，需要初始化好内核的页表以及内存管理模块的元数据(比如物理内存大小，NUMA等信息)。进入虚拟模式的内核态，便可以管理内存。
内存分为DMA(一般处于低物理地址，因为一般总线地址空间小于物理内存地址空间)，NORMAL和HIGH(X64不需要)。

slab分配
------------------
一般上内核分配是整页为单位的，但有时也分配小的块，这部分由slab分配器实现。

